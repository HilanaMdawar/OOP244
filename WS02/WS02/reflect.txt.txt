I learned the proper use and importance of safe dynamic memory allocation in C++. I worked with raw pointers to allocate memory for C-style strings and integer arrays. I practiced setting pointers to nullptr and sizes to zero to ensure the program remains in a safe empty state when no data is stored. Implementing the Samples structure helped me understand data ownership, especially how memory can be allocated in one function and properly deallocated in another.

One of the most valuable concepts I learned was how to expand a dynamic array during program execution. I managed sensor data of unknown size by creating a new array, copying existing values, appending new data, and deleting the old array safely. This clarified why pointers must be passed by reference, such as int*& and Samples*&, when the goal is to update the callerâ€™s pointer.

The biggest challenge I faced was managing memory deallocation correctly and avoiding memory leaks. I addressed this by carefully reviewing my logic, checking program output, and using Valgrind to confirm that all dynamically allocated memory was freed. I used AI as a reference to clarify some concepts related to pointers and dynamic memory rules, but the final implementation, debugging, and testing were completed independently. This workshop increased my confidence in dynamic memory management and modular program design.
